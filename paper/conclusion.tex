\section{Conclusion}
\label{sec:conclusion}
\label{sec:discussion}

In this paper we have shown that the standard characterisations of
  the \mustpreorder by De Nicola and
  Hennessy~\cite{DBLP:journals/tcs/NicolaH84,DBLP:books/daglib/0066919}
  are sound and complete also in an asynchronous setting, provided servers are
  enhanced with the forwarding ability.
  \rlem{liftFW-works} shows that this lifting is always possible.
  %
  We have also shown that the standard coinductive characterisation carries over to the
  asynchronous setting.
  %
  Our results %\ila{closes the problem left open by \cite{Tanti2015TowardsSR},}
  are supported by %and is also
  the first mechanisation of the \mustpreorder, and increase proof
  (i.e. code) factorisation and reusability since the alternative preorders
  do not need to be changed when shifting between synchronous and
  asynchronous semantics: it is enough to parameterise the proofs on
  the set of non-blocking actions.
    % This result closes the problem left open by
  %   \cite{Tanti2015TowardsSR}, \ila{is supported by} %and is also
  %   the first mechanisation of the
  %   \mustpreorder, and increases \ila{proof} (i.e. code)
  % factorisation and reuse: we do not need to change the definitions of
  % the alternative preorders to reason on synchronous systems, we need
  % only to parametrise the proofs on the set of non-blocking actions.
%
  %% \ilacom{This paragraph seems slightly redundant. Omit
  %%   the first sentence (which appears already in the last line of the abstract)?} 
  %% \rthm{testleqS-equals-accleq} and
  %% \rthm{testleqS-equals-mustsetleq} suggest a technique to port
  %% characterisations of testing preorders from synchronous to
  %% asynchronous semantics.
%
% \rthm{testleqS-equals-accleq} and \rthm{testleqS-equals-mustsetleq}
% suggest a technique to port characterisations of testing
% preorders from synchronous semantics to asynchronous ones,
% i.e. by  enhancing servers with the forwarding ability.
% \rlem{liftFW-works} shows that this lifting is always possible,
% \gb{and \cite{DBLP:conf/birthday/BaldanBGV15} is another case-study,
%   for it shows that this technique works also for the $\May$-preorder.
%
  \rcor{testleqS-equals-failleq} states that \mustpreorder and failure
  refinement essentially coincide. This might spur further interest in
  the mechanisations of the latter
  \cite{HOL-CSP-AFP,DBLP:journals/acta/BaxterRC22}, possibly leading
  to a joint development.%
 %% LICS TEXT
 %%While this approach was originally suggested by \cite{DBLP:conf/fsttcs/CastellaniH98},
 %%Selinger axioms play a crucial role in the proof of completeness.
 %% NEW TEXT


\paragraph{Proof method for \mustpreorder}
Theorems \ref{thm:testleqS-equals-asleq}, \ref{thm:coinductive-char-equiv-main}
and \ref{thm:testleqS-equals-mustsetleq} endow researchers in programming
languages for message-passing software with a proof method for~$\testleqS$,
namely: to define for their calculi an LTS that enjoys the axioms of
output-buffered agents with feedback. % for the language at issue.
%A concrete example of this approach is \rcor{characterisation-for-aCCS}.
An example of this approach is \rcor{characterisation-for-aCCS}.
% define an LTS for the language at issue,
% that enjoys the axioms of output-buffered agents with feedback.
%
%% \begin{enumerate}[(1)]
%% \item defining an LTS for their language, and
%% \item proving that the LTS is an instance of the typeclass for
%%   output-buffered agents with feedback.
%% \end{enumerate}


\paragraph{Live programs have barred trees}  We argued that a proof
of $\Must{\server}{\client}$ is a proof of liveness (of the
client). This paper is thus de facto an example that proving
liveness amounts to prove that a computational tree has a bar (identified
by the predicate $\goodSym$), and hence \barinduction is a natural way
to reason constructively on liveness-preserving manipulations on programs.
%% LONG VERSION
  %% as
  %% it gives an inductive principle for properties Ã  la
  %% \cite{DBLP:journals/tse/Lamport77}: "for each execution, eventually
  %% something good happens".
  While this fact seems to be by and large 
  unexploited by the PL community, we believe that it may %in fact
  be of interest to practitioners reasoning on liveness
  properties %wishing to prove liveness results
  in theorem provers in particular, and to the PL
  community at large.

\paragraph{Mechanisation} %
Boreale and Gadducci~\cite{DBLP:journals/tcs/BorealeG06} remark that the
\mustpreorder lacks a tractable proof method.  In constrast, we argue that our
contributions, in particular the coinductive characterisation
(\rthm{coinductive-char-equiv-main}), being fully mechanised in Coq, let
practitioners pursue non-trivial results about testing preorders for real-world
programming languages.  
%
To make this point, we have proved a form of code-hoisting using this
characterisation.
%
Our mechanisation lowers the barrier to entry for
researchers versed into theorem provers and wishing to use testing preorders;
adds to the toolkit of Coq users an alternative to the well-known (and already
mechanised) bisimulation equivalence \cite{DBLP:conf/lics/Pous16}; and provides
a starting point for researchers willing to study testing preorders and
analogous refinements within type theory.  Our code is open-source and available
on-line. %Practitioners
Researchers working on testing preorders may benefit from it, as
there are analogies between reasoning techniques for \textsc{May}, $\opMust$,
\textsc{Compliance}, \textsc{Should}, and \textsc{Fair} testing. For instance
Baldan et al. show with pen and paper that a technique similar to forwarding
works to characterise the $\May$-preorder~\cite{DBLP:conf/birthday/BaldanBGV15}.
%  

\paragraph{Future work}  Thanks to Theorems \ref{thm:testleqS-equals-asleq},
\ref{thm:coinductive-char-equiv-main} and \ref{thm:testleqS-equals-mustsetleq}
we can now set out to (1) devise an
axiomatisation of~$\testleqS$ for asynchronous calculi, as done in
\cite{DBLP:journals/fac/HennessyI93,DBLP:journals/iandc/BorealeN95,DBLP:books/daglib/0066919,DBLP:journals/tcs/Hennessy02}
for synchronous ones; (2) study for which asynchronous calculi~$\testleqS$ is a
pre-congruence; (3) machine-check semantic models of subtyping for session types
\cite{DBLP:journals/mscs/BernardiH16}; (4) study the decidability
of~$\testleqS$.  We conjecture that in Selinger asynchronous setting the
\mustpreorder is undecidable.

More in general, given the practical relevance of asynchronous
communication, it seems crucial %
%natural \ilacom{utiliser un adjectif plus percutant que ``natural''? Crucial?}
not only to adapt the large body of theory for synchronous
communication to the asynchronous setting but also to resort to
machine supported reasoning to do it. This paper is meant to be a step
forward in this direction.


% {Related work}
% \rapp{detailed-related-works} contains a detailed discussion of related works.
% Here we highlight that the notion of forwarder was outlined in the
% original paper on testing-preorders for asynchrony
% \cite{DBLP:conf/fsttcs/CastellaniH98}, and then
% used in the saturated LTS of \cite{DBLP:conf/birthday/BaldanBGV15}
% to reason on the $\opMay$-preorder, and in \cite{DBLP:phd/us/Thati03}
% to reason on a version of the \mustpreorder parametrised on the set of
% tests.
% Forwarders, also called ``links'', have applications outside of
% testing theory, as shown by \cite{DBLP:journals/mscs/MerroS04}
% and the recent \cite{DBLP:journals/tcs/DurierHS22}.
% Characterising~$\testleqS$ directly on LTSs instead of calculi 
% was suggested already in \cite{DBLP:books/daglib/0066919,phdbernardi}.
%   %% Page numbers, FOR LONG VERSION
% % on \cite[pag. 211]{DBLP:books/daglib/0066919} and \cite[pag. 93]{phdbernardi}
% Selinger axioms, discussed also by \cite{DBLP:journals/mscs/BaldanBGM15}, are
% crucial in our completeness proof.
% Brouwer \barinduction principle is paramount to prove soundness
% constructively.

%% we prove this for the LTS of \ACCS modulo $\equiv$ in
%% \rlem{ACCSmodulos-equiv-is-out-buffered-with-feedback}
%% and hence we obtain as a corollary of~\rthm{testleqS-equals-accleq}
%% a characterisation of~$\testleqS$ for this language:
%% $$
%% \forall \serverA, \serverB \in \modulo{\ACCS}{\equiv} \wehavethat \serverA \testleqS \serverB \text{ iff } \ltsFWof{\serverA} \asleq \ltsFWof{\serverB}.
%% $$

%%% LONG DISCUSSION FIT FOR A JOURNAL
%% Furthermore, our characterisations use the standard definitions of the
%% alternative preorders~$\msleq$ and~$\asleq$, which are simpler than
%% the ones proposed in \cite{DBLP:conf/fsttcs/CastellaniH98,
%%   DBLP:journals/iandc/BorealeNP02}.
%% Our approach places the complexity of reasoning on asynchrony into the LTSs themselves,
%% and, above all, into our proofs, which are more general than the
%% proofs of equations~(\ref{eq:bhv-mustset-characterisation})
%% and~(\ref{eq:bhv-accset-characterisation}) on
%% page~\pageref{eq:bhv-mustset-characterisation}.  This is the case
%% because proofs for the synchronous semantics are simpler than the ones
%% for the asynchronous one, since they do not have to tackle the
%% asymmetry between non-blocking outputs and blocking inputs.

%%In addition to the theoretical contributions, we provide a


  
%% Since the logic implemented by Coq is constructive, and since our proofs do
%% not use axioms other than \barinduction, they are constructive by construction.

%% In particular, the standard technique to prove soundness of
%% alternative characterisations


%


  %% and contradiction in the constructive sense: the negation of~$A$ is defined as
  %% ``$A$ implies~$\bot$'', so that, to prove the negation of~$A$, we can
  %% assume~$A$ holds and derive a contradiction.


